--MOSTRAR LOS DEPARTAMENTOS DE MADRID
SELECT DEPT_NO
  FROM DEPART
    WHERE LOC='MADRID';

--MOSTRAR EL APELLIDO Y SALARIO DE LOS EMPLEADOS DEL DEPARTAMENTO 20
SELECT APELLIDO, SALARIO
  FROM EMPLE
    WHERE DEPT_NO=20;
--MOSTRAR LOS EMPLEADOS QUE NO SON DIRECTORES
SELECT EMP_NO
  FROM EMPLE 
    WHERE OFICIO<>'DIRECTOR';
--MOSTRAR LOS EMPLEADOS QUE ENTRARON A TRABAJAR DESPUÉS DEL 31/12/2010
SELECT EMP_NO
  FROM EMPLE
    WHERE FECHA_ALTA>'31/12/2010';
--MOSTRAR EMPLEADOS CON SALARIO MAYOR O IGUAL QUE 2000.
SELECT EMP_NO
  FROM EMPLE
    WHERE SALARIO>='2000';
--MOSTRAR EMPLEADOS CON SALARIO ENTRE 1400 Y 1900 EUROS.
SELECT *
  FROM EMPLE
    WHERE SALARIO BETWEEN '1400' AND '1900';
--MOSTRAR EMPLEADOS CON SALARIO QUE NO ESTE ENTRE 1400 Y 1900 EUROS.
SELECT *
  FROM EMPLE
    WHERE SALARIO NOT BETWEEN '1400' AND '1900';
--MOSTRAR EMPLEADOS QUE SUS APELLIDOS ESTÁN ENTRE ARROYO Y FERNANDEZ
SELECT *
  FROM EMPLE
    WHERE APELLIDO BETWEEN 'ARROYO' AND 'FERNANDEZ'
SELECT SYSDATE  --VARIABLE QUE TIENE LA FECHA Y HORA DEL SISTEMA
  FROM DUAL; --TABLA VACÍA QUE SIRVE PARA HACER PRUEBAS
SELECT USER
  FROM DUAL;  --USUARIO CONECTADO
--EMPLEADOS QUE ENTRARON A TRABAJAR ENTRE LOS AÑOS 2009 Y 2015
SELECT *
  FROM EMPLE
    WHERE FECHA_ALTA BETWEEN '01/01/09' AND '31/12/15';

SELECT APELLIDO
  FROM EMPLE
    WHERE APELLIDO LIKE 'S%';  --APELLIDO TIENE UNA S AL PRINCIPIO Y "LUEGO LO QUE SEA"=%.

SELECT APELLIDO
  FROM EMPLE
    WHERE APELLIDO LIKE '%S';

--APELLIDO TERMINA POR Z  
SELECT APELLIDO
  FROM EMPLE
    WHERE APELLIDO LIKE '%Z';
--QUE CONTENGA UNA A
SELECT APELLIDO
  FROM EMPLE
    WHERE APELLIDO LIKE '%A%';
--QUE NO CONTENGA UNA A
SELECT APELLIDO
  FROM EMPLE
    WHERE APELLIDO NOT LIKE '%A%';

SELECT APELLIDO 
  FROM EMPLE
    WHERE APELLIDO LIKE '_A%'  --LOS QUE TIENEN UNA A EN LA 2ª OPCIÓN

--APELLIDOS QUE TIENEN EXACTAMENTE 5 LETRAS
SELECT APELLIDO
  FROM EMPLE
    WHERE APELLIDO LIKE '_____';

--OPERADORES DE COMPARACIÓN 
--IN= SIRVE PARA ESPECIFICAR UN COJUNTO DE VALORES. SINTAXIS: CAMPO IN (VALOR 1, VALOR 2,...,)
SELECT *
  FROM EMPLE
    WHERE DEPT_NO IN (10,20,30,40);
SELECT *
  FROM EMPLE
    WHERE DEPT_NO NOT IN (10,20,30,40);
--EL OFICIO SEA VENDEDOR, CAMARERO Y 
SELECT*
  FROM EMPLE
    WHERE OFICIO IN ('VENDEDOR','CAMARERO','PRESIDENTE');
--APELLIDO, SALARIO Y LA COMISIÓN
SELECT APELLIDO, SALARIO, COMISION
  FROM EMPLE
    WHERE DEPT_NO = 30;
    
SELECT *
  FROM EMPLE
    WHERE COMISION IS NULL;

--EMPLEADOS DEL DEPARTAMENTO 10 QUE SON DIRECTOR.
SELECT *
  FROM EMPLE
    WHERE DEPT_NO = 10
      AND OFICIO = 'VENDEDOR';

SELECT *
  FROM EMPLE
    WHERE DEPT_NO IN (20,30)
      AND OFICIO = 'DIRECTOR'
      AND SALARIO > 3000;

SELECT *
  FROM EMPLE
    WHERE DEPT_NO IN (20,30)
      OR OFICIO = 'DIRECTOR'
      OR SALARIO > 3000;
    
--SI MEZCLAMOS OR Y AND TENER CUIDADO EN PONER PARENTESIS () 
SELECT *
  FROM EMPLE
    WHERE DEPT_NO IN (20,30)
      AND (OFICIO = 'DIRECTOR'
        OR SALARIO > 3000;)
        
SELECT *
  FROM EMPLE
    WHERE (DEPT_NO IN (20,30)
      AND OFICIO = 'DIRECTOR')
        OR SALARIO > 3000;

--QUIERO QUE CUMPLA QUE SEA DEL DEPARTAMENTO Y (DIRECTOR O SALARIO TAL)
SELECT *
  FROM EMPLE
    WHERE DEPT_NO IN (20,30);
      AND (OFICIO = 'DIRECTOR'
        OR SALARIO > 3000);
    
--SALARIO SI LE SUBO 300 EUROS, SUBIR SALARIO 10% (PUEDO USAR ALIAS PA Q SE VEA MAS BONITO)
SELECT APELLIDO, SALARIO, SALARIO+300 "NUEVO SALARIO",SALARIO + SALARIO*10/100 "+10%"
  FROM EMPLE
    WHERE DEPT_NO = 10;
    

--ORDENAR DATOS
  SELECT * FROM EMPLE
    ORDER BY OFICIO;

--ORDENAR DATOS DE FORMA DESCENDENTE
  SELECT * FROM EMPLE
    ORDER BY FECHA_ALTA DESC;
    
--ORDENAR COMO YO QUIERA
  SELECT DEPT_NO, OFICIO, SALARIO, APELLIDO
    FROM EMPLE
      ORDER BY DEPT_NO, OFICIO, SALARIO;
      
  SELECT DEPT_NO, OFICIO, SALARIO, APELLIDO
    FROM EMPLE
      WHERE COMISION IS NOT NULL
        ORDER BY DEPT_NO, OFICIO, SALARIO;

--COMBINAR TABLAS
SELECT APELLIDO, EMPLE.DEPT_NO, DEPART.DEPT_NO, DNOMBRE, LOC
  FROM EMPLE, DEPART
    WHERE EMPLE.DEPT_NO = DEPART.DEPT_NO;

SELECT APELLIDO, EMPLE.DEPT_NO, DEPART.DEPT_NO, DNOMBRE, LOC
  FROM EMPLE JOIN DEPART ON EMPLE.DEPT_NO = DEPART.DEPT_NO;



SELECT APENOM, ALUMNOS.DNI, NOTAS.DNI
  FROM EMPLE JOIN DEPART ON ALUMNOS.DNI = NOTAS.DNI
    WHERE NOTAS IN (1,2,3,4);



--EMPLEADOS CON EL MISMO SALARIO QUE JIMENO (SUBCONSULTAS)
SELECT *
  FROM EMPLE
    WHERE SALARIO = (SELECT SALARIO FROM EMPLE WHERE APELLIDO = 'JIMENO');

SELECT*
  FROM EMPLE
    WHERE SALARIO < (SELECT SALARIO FROM EMPLE WHERE APELLIDO = 'JIMENO');
    

--REDONDEAR
SELECT APELLIDO,SALARIO, ROUND (SALARIO/3), ROUND (SALARIO/3,2)
  FROM EMPLE;

--TRUNCAR, ES DECIR SE QUEDA LA PARTE ENTERA SIN REDONDEAR NI NADA
SELECT APELLIDO,SALARIO, TRUNC (SALARIO/3), TRUNC (SALARIO/3,2)
  FROM EMPLE;

--MOD, FUNCIÓN QUE DEVUELVE EL RESTO DE LA DIVISIÓN ENTERA ENTRE DOS NÚMEROS.
--PARA HACER PRUEBAS PODEMOS UTILIZAR UNA TABLA QUE ESTÁ VACÍA Y SE LLAMA DUAL.
SELECT 'PEPE', MOD(23,4), MOD(100,10)
  FROM DUAL;

--CUANDO HACES OPERACIONES CON COLUMNAS Y UNA DE ELLAS ES NULL DA NULL.
SELECT SALARIO, COMISION, SALARIO+COMISION
  FROM EMPLE
    WHERE DEPT_NO=30;
--SOLUCIÓN:NVL, RECIBE 2 VALORES Y DEVUELVE EL PRIMER VALOR QUE NO SEA NULO, CUANDO COMISION SEA NULL COGE EL 0.
SELECT SALARIO, COMISION, SALARIO + NVL (COMISION,0)
  FROM EMPLE
    WHERE DEPT_NO=30;

--MAXIMO, MINIMO, SUMA DE SALARIOS, MEDIA
SELECT MAX (SALARIO), MIN (SALARIO), SUM (SALARIO), ROUND (AVG (SALARIO))
  FROM EMPLE
    WHERE DEPT_NO = 30;
--PARA MAX Y MIN SE OLVIDA DE LOS VALORES NULL
--SÍ LO HAGO DE FORMA DE CARACTERES LO HACE ALFABETICAMENTE
SELECT MAX (APELLIDO), MIN (SALARIO)
  FROM EMPLE
    WHERE DEPT_NO = 30;
--CON FECHAS TAMBIÉN.
SELECT MAX (FECHA_ALTA), MIN (FECHA_ALTA)
  FROM EMPLE
    WHERE DEPT_NO = 30;

--CONTAR FILAS
SELECT COUNT (*)
  FROM EMPLE
    WHERE DEPT_NO = 30;
--SI LO HAGO CON UNA COLUMNA CUENTA CUANTAS FILAS HAY CON ESA COLUMNA QUE SEA NO NULL.
SELECT COUNT (*), COUNT (APELLIDO), COUNT (COMISION)
  FROM EMPLE
    WHERE DEPT_NO = 30;
--¿SÍ QUIERO SABER CUANTOS NULLS HAY?
SELECT COUNT (*), COUNT (APELLIDO), COUNT (COMISION), COUNT (*) - COUNT (COMISION) "COMISION NULA"
  FROM EMPLE
    WHERE DEPT_NO = 30;
--CONTAR DISTINTOS OFICIOS
  SELECT COUNT (DISTINCT OFICIO)
    FROM EMPLE
      WHERE DEPT_NO = 30;
  
  

--NNNNNNOTTTTTTT INNNNN    DEPARTAMENTOS QUE NO TIENEN EMPLEADOS
      SELECT *
        FROM DEPART
          WHERE DEPT_NO NOT IN (SELECT DEPT_NO FROM EMPLE);
    --NOMBRE DE LOS ALUMNOS QUE HAN APROBADO TODO = LOS QUE NO ESTÁN ENTRE LOS QUE HAN SUSPENDIDO ALGO.
    SELECT APENOM
      FROM ALUMNOS
        WHERE DNI NOT IN (SELECT DNI FROM NOTAS WHERE NOTA < 5);
    
    --ALUMNOS QUE NO HAN TENIDO NUNCA UN 3.
    SELECT APENOM
      FROM ALUMNOS
        WHERE DNI NOT IN (SELECT DNI FROM NOTAS WHERE NOTA = 3);
    
    --ATRACCIONES QUE NUNCA SE HAN AVERIADO = LAS QUE NO ESTAN EN LA TABLA AVERIAS PARQUE.
    SELECT *
      FROM ATRACCIONES
        WHERE COD_ATRACCION NOT IN (SELECT COD_ATRACCION FROM AVERIAS_PARQUE);
        
    --ATRACCIONES QUE NO SE HAN AVERIADO NUNCA CON COSTE MAYOR QUE 4000
      SELECT *
        FROM ATRACCIONES
          WHERE COD_ATRACCION NOT IN (SELECT COD_ATRACCION FROM AVERIAS_PARQUE WHERE COSTE_AVERIA > 4000);


--MOSTRAR LOS 3 PRIMEROS CARACTERES DEL APELLIDO DE CADA EMPLEADO
SELECT SUBSTR (APELLIDO, 1, 3)
  FROM EMPLE;

SELECT SUBSTR ('HOLA CARACOLA', 1, 4)
  FROM DUAL;
  
SELECT SUBSTR ('HOLA CARACOLA', 10, 6)
  FROM DUAL;

SELECT SUBSTR (APELLIDO,4)
  FROM EMPLE;

SELECT SUBSTR ('HOLA CARACOLA', -1)
  FROM DUAL;

      --TABLA EMPLE MOSTRAR DE LOS EMPLEADOS DEL DEPARTAMENTO 30
        --APELLIDO Y OFICIO
        SELECT APELLIDO, OFICIO, SUBSTR (APELLIDO,1,1)
          FROM EMPLE
            WHERE DEPT_NO = 30;
        --LA INICIAL DEL APELLIDO
        SELECT SUBSTR (APELLIDO, 1,1) FROM EMPLE;
        --LAS DOS ULTIMAS LETRAS DEL OFICIO 
        SELECT SUBSTR (OFICIO,-2) FROM EMPLE;
        --EL OFICIO EN MINUSCULAS
        SELECT LOWER (OFICIO) FROM EMPLE;
        --EL APELLIDO EN FORMATO TÍTULO
        SELECT INITCAP (APELLIDO) FROM EMPLE;

--CONCATENAR
    --ARROYO-VENDEDOR GANA 1500€
    SELECT APELLIDO||'-'||OFICIO||' GANA '||SALARIO||'€'
      FROM EMPLE;
    --MOSTRAR DE LA TABLA ALUMNOS APENOM Y SEGUIDO DE *** Y EL TELEFONO SEPARADOS LOS DIGITOS DE 3 EN 3.
    SELECT APENOM||' *** '||SUBSTR (TELEF, 1,3)||' '||SUBSTR (TELEF, 4,3)||' '||SUBSTR (TELEF, 7,3) 
      FROM ALUMNOS;
      
  
  SELECT APELLIDO, LENGTH(APELLIDO)
    FROM EMPLE
      WHERE LENGTH (APELLIDO) <= 7;

--MOSTRAR LAS ATRACCIONES PONIENDO EN MAYÚSCULA LA ZONA Y SACANDO CUANTOS CARACTERES TIENE EL NOM_ATRACCION
  SELECT NOM_ATRACCION, UPPER (NOM_ATRACCION), LENGTH(NOM_ATRACCION)
    FROM ATRACCIONES;




--FUNCIONES CON FECHAS
  --fecha y hora del sistema
  SELECT SYSDATE
    FROM DUAL; --tabla que solo tiene una fila para hacer pruebas.
  --cambiar el formato de la fecha hora
  ALTER SESSION SET NLS_DATE_FORMAT= 'DD/MM/YYYY HH24:MI:SS';
  --dd
  --mm
  --yy
  --yyyy
  --hh24 horas en formato 24h
  --mi segundis
  --ss segundos
  --d dia de la semana en letra 
  --day dia de la semana en letra
  --month mes en letra
  ALTER SESSION SET NLS_DATE_FORMAT= 'DD/MM/YY';
  
  --LA RESTA DE DOS FECHAS DEVUELVE EL NÚMERO DE DÍAS QUE HAN TRANSCURRIDO ENTRE ESAS FECHAS
  SELECT SYSDATE - FECHA_ALTA
    FROM EMPLE;
    --AÑOS ((F1-F2)/365)
  SELECT APELLIDO, TRUNC((SYSDATE - FECHA_ALTA)/365.25) "AÑOS EN LA EMPRESA"
    FROM EMPLE;
  --AL SUMAR UN NÚMERO A UNA FECHA ESTAMOS SUMANDOLES DÍAS (O RESTANDOLE)
  SELECT SYSDATE + 0.5 --medio dia
    FROM DUAL;
    
--mostrar en las averias parque cuantos dias ha estado estropeada cada averia q ya esta arreglada
  SELECT TRUNC(FECHA_ARREGLO - FECHA_FALLA)
    FROM AVERIAS_PARQUE
      WHERE FECHA_ARREGLO IS NOT NULL;

--para las averías sin arreglar mostrar cuantos días llevan estropeadas
  SELECT TRUNC (SYSDATE - FECHA_FALLA)
    FROM AVERIAS_PARQUE
      WHERE FECHA_ARREGLO IS NULL;

--cuantos años lleva en el parque la empleada Ana Gil y cuantos trienios.
  SELECT TRUNC((SYSDATE - ALTA_EMPRESA)/365.25) años, TRUNC ((SYSDATE - ALTA_EMPRESA)/(365.25*3)) trienio
    FROM EMPLE_PARQUE
      WHERE NOM_EMPLEADO = 'Ana Gil';


--sacar de la fecha de alta solo una parte, TO CHAR DEVUELVE UNA CADENA DE TEXTO CON LO QUE SE HA ESPECIFICADO DE FROMATO PARA LA FECHA
SELECT TO_CHAR(FECHA_ALTA,'MM - YYYY'), APELLIDO
  FROM EMPLE;

SELECT TO_CHAR(SYSDATE,'DAY') FROM DUAL;

--tambn se puede usar en el where
SELECT *
  FROM EMPLE
    WHERE TO_CHAR(FECHA_ALTA, 'YYYY') = 2017;

--empleados q entraron en enero, febrero, marzo, septiembre
SELECT *
  FROM EMPLE
    WHERE TO_CHAR(FECHA_ALTA, 'MM') IN (1,2,3,9);
--empleados q entraron en enero, febrero, marzo
SELECT *
  FROM EMPLE
    WHERE TO_CHAR(FECHA_ALTA, 'MM') BETWEEN 1 AND 3;
--empleados q entraron un lunes
SELECT *
  FROM EMPLE
    WHERE TO_CHAR(FECHA_ALTA, 'D') = 1; 
--empleados q entraron un lunes
SELECT *
  FROM EMPLE
    WHERE TO_CHAR(FECHA_ALTA, 'DAY') = 'LUNES'; --no hacer esto mejor
  --mEJOR ESTO
    SELECT *
      FROM EMPLE
        WHERE TO_CHAR(FECHA_ALTA, 'D') = '1';
--TO_DATE DEVUELVE UNA FECHA ECON ESE FORMATO
SELECT TRUNC (SYSDATE - TO_DATE('01/05/2003','DD/MM//YYYY'))
  FROM DUAL;

--MOSTRAR 
SELECT TO_CHAR(FECHA_ENTRADA, 'DAY'), TO_CHAR(FECHA_SALIDA, 'HH24:MI'),IMPORTE+IMPORTE*10/100,
SUBSTR(ARREGLOS.MATRICULA,1,4), TRUNC((FECHA_SALIDA-FECHA_ENTRADA)*24),
SUBSTR(MECANICOS.NOMBRE,1,1), INITCAP(FUNCION), CLIENTES_TALLER.TELEFONO, AÑO_MATRICULA||'/'||MODELO
  FROM MECANICOS JOIN ARREGLOS ON ARREGLOS.NEMPLEADO = MECANICOS.NEMPLEADO
    JOIN COCHES_TALLER ON COCHES_TALLER.MATRICULA = ARREGLOS.MATRICULA
      JOIN CLIENTES_TALLER ON CLIENTES_TALLER.NCLIENTE = COCHES_TALLER.NCLIENTE
        WHERE TO_CHAR(FECHA_ENTRADA,'MM/YYYY') = '05/2020'
            AND FECHA_SALIDA IS NOT NULL;
        

--MECANICOS QUE NO TIENEN ARREGLOS
SELECT *
  FROM MECANICOS
    WHERE NEMPLEADO NOT IN (SELECT NEMPLEADO FROM ARREGLOS);
--MECANICOS QUE NO TIENEN ARREGLOS EN MAYO 2020
SELECT *
  FROM MECANICOS
    WHERE NEMPLEADO NOT IN (SELECT NEMPLEADO FROM ARREGLOS WHERE TO_CHAR(FECHA_ENTRADA,'MM/YYYY') = '05/2020');
--MECANICOS QUE NO TIENEN ARREGLOS CON COCHES CITROEN
SELECT *
  FROM ARREGLOS
    WHERE MATRICULA NOT IN (SELECT MATRICULA FROM COCHES_TALLER WHERE MODELO NOT LIKE 'CITROEN C3');




--GROUP BY(AGRUPACIONES)
SELECT DEPT_NO,COUNT(*),MAX(SALARIO),MIN(SALARIO)
FROM EMPLE
GROUP BY DEPT_NO
ORDER BY DEPT_NO ASC;

SELECT DEPT_NO,COUNT(OFICIO),COUNT(DISTINCT OFICIO),COUNT(COMISION)
FROM EMPLE
GROUP BY DEPT_NO
ORDER BY DEPT_NO ASC;

SELECT OFICIO,SUM(SALARIO),COUNT(APELLIDO)
FROM EMPLE
GROUP BY OFICIO;

SELECT TO_CHAR(FECHA_ALTA,'YYYY'),COUNT(APELLIDO)
FROM EMPLE
GROUP BY TO_CHAR(FECHA_ALTA,'YYYY')
ORDER BY TO_CHAR(FECHA_ALTA,'YYYY');

SELECT  TO_CHAR(FECHA_ALTA,'YYYY'),COUNT(APELLIDO)
FROM EMPLE
WHERE OFICIO NOT LIKE 'DIRECTOR'
GROUP BY  TO_CHAR(FECHA_ALTA,'YYYY')
ORDER BY  TO_CHAR(FECHA_ALTA,'YYYY') ASC;

SELECT DNOMBRE,COUNT(E.EMP_NO)
FROM EMPLE E, DEPART D
WHERE E.DEPT_NO = D.DEPT_NO
GROUP BY DNOMBRE;

SELECT DEPT_NO,OFICIO,COUNT(*)
FROM EMPLE
GROUP BY DEPT_NO,OFICIO
ORDER BY DEPT_NO DESC;


--GROUP BY -- HAVING
--Mostrar por cada departamento sin tener en cuenta a los directoes cuantos empleados hay y 
--cual es la suma de los salarios pero solo para departamentos con más de 3 empleados.

SELECT DEPT_NO, COUNT(*), SUM(SALARIO)
  FROM EMPLE
    WHERE OFICIO != 'DIRECTOR'
      GROUP BY DEPT_NO
        HAVING;
--Por cada oficio max salario y cuantos empleados pero solo para oficios con salario max mayor que 2000     
SELECT MAX(SALARIO), OFICIO
  FROM EMPLE
    GROUP BY OFICIO
      HAVING MAX(SALARIO)>2000;

--Nombre de las asignaturas con más de un suspenso
SELECT NOMBRE, COUNT (*)
  FROM ASIGNATURAS JOIN NOTAS ON NOTAS.COD = ASIGNATURAS.COD
    WHERE NOTA < 5
      GROUP BY NOMBRE
        HAVING COUNT(*) > 1;
--Alumnos con nota media > 6
SELECT APENOM
  FROM ALUMNOS JOIN NOTAS ON NOTAS.DNI = ALUMNOS.DNI
      GROUP BY APENOM
        HAVING AVG(NOTA)>6;

--Nombre de las atracciones de la zona infantil con mas de 2 averias
SELECT NOM_ATRACCION, COUNT(*)
  FROM ATRACCIONES JOIN AVERIAS_PARQUE ON AVERIAS_PARQUE.COD_ATRACCION = ATRACCIONES.COD_ATRACCION
    WHERE NOM_ZONA = 'Infantil'
      GROUP BY NOM_ATRACCION
        HAVING COUNT(*)>2;
        
--Agrupar los empleados por oficio y mostrar cuantos empleados tiene cada oficio
SELECT OFICIO, COUNT(*)
  FROM EMPLE
    GROUP BY OFICIO;

--Mostrar el oficio que más empleados tiene
SELECT OFICIO, COUNT(APELLIDO)
  FROM EMPLE
    GROUP BY OFICIO
      HAVING COUNT(APELLIDO) = (SELECT MAX (COUNT(APELLIDO))
                                  FROM EMPLE
                                    GROUP BY OFICIO);
--MOSTRAR EL OFICIO QUE MENOS EMPLEADOS TIENE SIN TENER EN CUENTA PRESIDENTE
SELECT OFICIO, COUNT(APELLIDO)
  FROM EMPLE
    GROUP BY OFICIO
      HAVING COUNT(APELLIDO) = (SELECT MIN (COUNT(APELLIDO))
                                  FROM EMPLE
                                    WHERE OFICIO NOT LIKE 'PRESIDENTE'
                                      GROUP BY OFICIO);
                                      
                                      
                                                                        
--Agrupar notas por asignatura y mostrar la mejor nota y la peor nota.
SELECT MAX(NOTA), MIN(NOTA), NOMBRE
  FROM NOTAS JOIN ASIGNATURAS ON ASIGNATURAS.COD = NOTAS.COD
    GROUP BY NOMBRE;
    
--Mostrar el nombre de la asiignatura que más suspensos tiene
SELECT NOMBRE, COUNT(*)
  FROM ASIGNATURAS JOIN NOTAS ON NOTAS.COD = ASIGNATURAS.COD
    WHERE NOTA<5
    GROUP BY NOMBRE
      HAVING COUNT(*) = (SELECT MAX(COUNT(*))
                            FROM NOTAS JOIN ASIGNATURAS ON ASIGNATURAS.COD = NOTAS.COD
                              WHERE NOTA<5
                              GROUP BY NOMBRE);
--Mostrar el nombre de la asignatura con más de 6
SELECT NOMBRE, COUNT(*)
  FROM ASIGNATURAS JOIN NOTAS ON NOTAS.COD = ASIGNATURAS.COD
    WHERE NOTA = 6
    GROUP BY NOMBRE
      HAVING COUNT(*) = (SELECT MAX(COUNT(*))
                            FROM NOTAS JOIN ASIGNATURAS ON ASIGNATURAS.COD = NOTAS.COD
                              WHERE NOTA = 6
                              GROUP BY NOMBRE);
    



